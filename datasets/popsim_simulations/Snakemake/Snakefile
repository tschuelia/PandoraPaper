import numpy as np
import pandas as pd
import pathlib
import shutil
import stdpopsim
from snakemake.executors import change_working_directory

from pandora.converter import run_convertf
from pandora.custom_types import FileFormat
from scripts.utils import get_n_samples_n_snps, collect_data_for_experiment, write_geno_file, write_ind_file, \
    write_pandora_config, write_snp_file


CONVERTF = pathlib.Path("convertf")
PLINK = pathlib.Path("plink")

if "/Users/julia" in os.getcwd():
    PLINK2 = pathlib.Path("/Users/julia/Software/plink2")
    N_BOOTSTRAPS = 10
    N_THREADS = 2
else:
    PLINK2 = pathlib.Path("plink2")
    N_BOOTSTRAPS = 100
    N_THREADS = 20


N_SAMPLES_PER_POP_FULL = 20
N_SAMPLES_PER_POP_SINGLE = 100
SEED = 42

SPECIES = "HomSap"

MODELS = {
    # model: exclude_pops
    "AshkSub_7G19": ["YRI", "CHB"],
    "OutOfAfricaExtendedNeandertalAdmixturePulse_3I21": [],
    "OutOfAfrica_3G09": [],
    # "OutOfAfrica_2T12": [],
    # "Africa_1T12": [],
    "AmericanAdmixture_4B11": [],
    "OutOfAfricaArchaicAdmixture_5R19": ["Neanderthal", "ArchaicAFR"],
    # "Zigzag_1S14": [],
    "AncientEurasia_9K19": ["BasalEurasian"],
    "PapuansOutOfAfrica_10J19": ["Den1", "Den2", "Nea1", "Ghost"],
    "OutOfAfrica_4J17": [],
    # "Africa_1B08": [],
    "AncientEurope_4A21": [],
}

SEQ_LENGTHS = ["1e5", "1e6", "1e7", "1e8"] #, "1e9"]
MISSING = [0.01, 0.05, 0.1, 0.2, 0.5]

OUTDIR_ALL_POPS = pathlib.Path(SPECIES) / ("{model}_{seq_len}_" + str(N_SAMPLES_PER_POP_FULL))
FULL_RESULT = pathlib.Path(SPECIES)


rule all:
    input:
        FULL_RESULT / "all_results.parquet"


rule simulate_no_missing:
    output:
        geno_file =OUTDIR_ALL_POPS / f"no_missing.geno",
        snp_file =OUTDIR_ALL_POPS / f"no_missing.snp",
        ind_file =OUTDIR_ALL_POPS / f"no_missing.ind",
    params:
        model = lambda wildcards: wildcards.model,
        seq_len = lambda wildcards: wildcards.seq_len,
    run:
        species = stdpopsim.get_species(SPECIES)
        model = species.get_demographic_model(params.model)
        contig = species.get_contig(mutation_rate=model.mutation_rate,length=eval(params.seq_len))

        # TODO: if SINGLE_POP:
        #     print(f"> Simulating data for a single population ({SINGLE_POP})")
        #     samples = {SINGLE_POP: N_SAMPLES_PER_POP}
        # else:
        exclude_populations = MODELS[params.model]
        samples = dict((p.name, N_SAMPLES_PER_POP_FULL) for p in model.populations if p.name not in exclude_populations)
        engine = stdpopsim.get_engine("msprime")
        ts = engine.simulate(model,contig,samples,seed=SEED)

        write_ind_file(ts, pathlib.Path(output.ind_file))
        write_snp_file(ts, pathlib.Path(output.snp_file))
        write_geno_file(ts, pathlib.Path(output.geno_file))


rule pandora_config:
    input:
        geno_file = rules.simulate_no_missing.output.geno_file,
        snp_file = rules.simulate_no_missing.output.snp_file,
        ind_file = rules.simulate_no_missing.output.ind_file,
    output:
        config_file = OUTDIR_ALL_POPS / "pandora_config.yaml",
    run:
        config_file = pathlib.Path(output.config_file)
        eigen_prefix = pathlib.Path(input.geno_file).with_suffix("")
        result_dir = eigen_prefix.parent / "results"

        write_pandora_config(
            eigen_prefix=eigen_prefix,
            result_dir=result_dir,
            config_file=config_file,
            n_bootstraps=N_BOOTSTRAPS,
            n_threads=N_THREADS,
            seed=SEED
        )


rule run_pandora:
    input:
        config_file = rules.pandora_config.output.config_file,
    output:
        pandora_result = OUTDIR_ALL_POPS / "results" / "pandora.txt",
        support_values = OUTDIR_ALL_POPS / "results" / "pandora.supportValues.csv",
    log:
        out = OUTDIR_ALL_POPS / "results" / "pandora.out",
        err = OUTDIR_ALL_POPS / "results" / "pandora.err",
    run:
        shell("pandora -c {input.config_file} > {log.out} 2> {log.err}")


rule eigen_to_plink:
    input:
        geno_file = rules.simulate_no_missing.output.geno_file,
        snp_file = rules.simulate_no_missing.output.snp_file,
        ind_file = rules.simulate_no_missing.output.ind_file,
    output:
        geno_file = OUTDIR_ALL_POPS / "no_missing_plink.bed",
        snp_file = OUTDIR_ALL_POPS / "no_missing_plink.bim",
        ind_file = OUTDIR_ALL_POPS / "no_missing_plink.fam",
    run:
        change_working_directory(OUTDIR_ALL_POPS)
        run_convertf(
            convertf=str(CONVERTF),
            in_prefix=pathlib.Path(input.geno_file).with_suffix(""),
            out_prefix=pathlib.Path(output.geno_file).with_suffix(""),
            in_format=FileFormat.EIGENSTRAT,
            out_format=FileFormat.PACKEDPED,
        )


rule maf_filtering:
    input:
        geno_file = rules.eigen_to_plink.output.geno_file,
        snp_file = rules.eigen_to_plink.output.snp_file,
        ind_file = rules.eigen_to_plink.output.ind_file,
    output:
        geno_file = OUTDIR_ALL_POPS / "maf_filtered.bed",
        snp_file = OUTDIR_ALL_POPS / "maf_filtered.bim",
        ind_file = OUTDIR_ALL_POPS / "maf_filtered.fam",
    log:
        out = OUTDIR_ALL_POPS / "maf_filtering.out",
        err = OUTDIR_ALL_POPS / "maf_filtering.err",
    run:
        change_working_directory(OUTDIR_ALL_POPS)
        plink_cmd = [
            str(PLINK2),
            "--bfile",
            f"{pathlib.Path(input.geno_file).with_suffix('')}",
            "--maf",
            "0.01",
            "--make-bed",
            "--out",
            f"{pathlib.Path(output.geno_file).with_suffix('')}",

        ]
        cmd = " ".join(plink_cmd) + " > {log.out} 2> {log.err}"
        shell(cmd)


rule ld_pruning:
    input:
        geno_file = rules.maf_filtering.output.geno_file,
        snp_file = rules.maf_filtering.output.snp_file,
        ind_file = rules.maf_filtering.output.ind_file,
    output:
        geno_file = OUTDIR_ALL_POPS / "ld_pruned.bed",
        snp_file = OUTDIR_ALL_POPS / "ld_pruned.bim",
        ind_file = OUTDIR_ALL_POPS / "ld_pruned.fam",
    log:
        out = OUTDIR_ALL_POPS / "ld_pruning.out",
        err = OUTDIR_ALL_POPS / "ld_pruning.err",
    run:
        change_working_directory(OUTDIR_ALL_POPS)
        # Step 1: find SNPs to filter out
        plink_cmd = [
            str(PLINK2),
            "--bfile",
            f"{pathlib.Path(input.geno_file).with_suffix('')}",
            "--indep-pairwise",
            "50",
            "5",
            "0.5",
            "--out",
            f"{pathlib.Path(output.geno_file).with_suffix('')}",
        ]
        cmd = " ".join(plink_cmd) + " > {log.out} 2> {log.err}"

        shell(cmd)

        # Step 2: filter out SNPs
        plink_cmd = [
            str(PLINK2),
            "--bfile",
            f"{pathlib.Path(input.geno_file).with_suffix('')}",
            "--extract",
            f"{pathlib.Path(output.geno_file).with_suffix('.prune.in')}",
            "--make-bed",
            "--out",
            f"{pathlib.Path(output.geno_file).with_suffix('')}",
        ]
        cmd = " ".join(plink_cmd) + " >> {log.out} 2>> {log.err}"

        shell(cmd)


rule plink_to_eigen:
    input:
        geno_file = rules.ld_pruning.output.geno_file,
        snp_file = rules.ld_pruning.output.snp_file,
        ind_file = rules.ld_pruning.output.ind_file,
        orig_ind_file = rules.simulate_no_missing.output.ind_file,
    output:
        geno_file = OUTDIR_ALL_POPS / "ld_pruned.geno",
        snp_file = OUTDIR_ALL_POPS / "ld_pruned.snp",
        ind_file = OUTDIR_ALL_POPS / "ld_pruned.ind",
    run:
        change_working_directory(OUTDIR_ALL_POPS)
        run_convertf(
            convertf=str(CONVERTF),
            in_prefix=pathlib.Path(input.geno_file).with_suffix(""),
            out_prefix=pathlib.Path(output.geno_file).with_suffix(""),
            in_format=FileFormat.PACKEDPED,
            out_format=FileFormat.EIGENSTRAT,
        )

        # Copy the original ind file since all the convertf + PLINK operations lost the population information
        # but first, make sure the individual IDs are the same
        orig_inds = pd.read_table(input.orig_ind_file, header=None, sep=" ")
        new_inds = pd.read_table(output.ind_file, header=None, sep=" ")
        if (orig_inds[0] == new_inds[0]).all():
            shutil.copy(input.orig_ind_file, output.ind_file)
        else:
            raise ValueError("Individual IDs do not match between the original and the new ind files")


rule pandora_config_ld_pruned:
    input:
        geno_file = rules.plink_to_eigen.output.geno_file,
        snp_file = rules.plink_to_eigen.output.snp_file,
        ind_file = rules.plink_to_eigen.output.ind_file,
    output:
        config_file = OUTDIR_ALL_POPS / "pandora_config_ld_pruned.yaml",
    run:
        config_file = pathlib.Path(output.config_file)
        eigen_prefix = pathlib.Path(input.geno_file).with_suffix("")
        result_dir = eigen_prefix.parent / "results_ld_pruned"

        write_pandora_config(
            eigen_prefix=eigen_prefix,
            result_dir=result_dir,
            config_file=config_file,
            n_bootstraps=N_BOOTSTRAPS,
            n_threads=N_THREADS,
            seed=SEED
        )


rule run_pandora_ld_pruned:
    input:
        config_file = rules.pandora_config_ld_pruned.output.config_file,
    output:
        pandora_result = OUTDIR_ALL_POPS / "results_ld_pruned" / "pandora.txt",
        support_values = OUTDIR_ALL_POPS / "results_ld_pruned" / "pandora.supportValues.csv",
    log:
        out = OUTDIR_ALL_POPS / "results_ld_pruned" / "pandora.out",
        err = OUTDIR_ALL_POPS / "results_ld_pruned" / "pandora.err",
    run:

        shell("pandora -c {input.config_file} > {log.out} 2> {log.err}")


rule add_random_missing_data:
    input:
        geno_file = rules.plink_to_eigen.output.geno_file,
        snp_file = rules.plink_to_eigen.output.snp_file,
        ind_file = rules.plink_to_eigen.output.ind_file,
    output:
        geno_file = OUTDIR_ALL_POPS / "missing_{missing}" / "missing_{missing}_ld_pruned.geno",
        snp_file = OUTDIR_ALL_POPS / "missing_{missing}" / "missing_{missing}_ld_pruned.snp",
        ind_file = OUTDIR_ALL_POPS / "missing_{missing}" / "missing_{missing}_ld_pruned.ind",
    params:
        missing = lambda wildcards: float(wildcards.missing),
    run:
        shutil.copy(input.ind_file, output.ind_file)
        shutil.copy(input.geno_file, output.geno_file)
        shutil.copy(input.snp_file, output.snp_file)

        geno = np.array([list(line.strip()) for line in open(output.geno_file).readlines()])
        geno = geno.astype(np.int8)

        num_missing = int(params.missing * geno.size)
        missing_indices = np.random.choice(geno.size,num_missing,replace=False)

        geno.ravel()[missing_indices] = 9
        open(output.geno_file, "w").writelines(["".join(row) + "\n" for row in geno.astype(str)])


rule pandora_config_ld_pruned_missing:
    input:
        geno_file = rules.add_random_missing_data.output.geno_file,
        snp_file = rules.add_random_missing_data.output.snp_file,
        ind_file = rules.add_random_missing_data.output.ind_file,
    output:
        config_file = OUTDIR_ALL_POPS / "missing_{missing}" / "pandora_config_ld_pruned.yaml",
    run:
        config_file = pathlib.Path(output.config_file)
        eigen_prefix = pathlib.Path(input.geno_file).with_suffix("")
        result_dir = eigen_prefix.parent / "results_ld_pruned"

        write_pandora_config(
            eigen_prefix=eigen_prefix,
            result_dir=result_dir,
            config_file=config_file,
            n_bootstraps=N_BOOTSTRAPS,
            n_threads=N_THREADS,
            seed=SEED
        )


rule run_pandora_ld_pruned_missing:
    input:
        config_file = rules.pandora_config_ld_pruned_missing.output.config_file,
    output:
        pandora_result = OUTDIR_ALL_POPS / "missing_{missing}" / "results_ld_pruned" / "pandora.txt",
        support_values = OUTDIR_ALL_POPS / "missing_{missing}" / "results_ld_pruned" / "pandora.supportValues.csv",
    log:
        out = OUTDIR_ALL_POPS / "missing_{missing}" / "pandora.out",
        err = OUTDIR_ALL_POPS / "missing_{missing}" / "pandora.err",
    run:
        shell("pandora -c {input.config_file} > {log.out} 2> {log.err}")


rule collect_results:
    input:
        # no missing, no LD pruning
        pandora_result = rules.run_pandora.output.pandora_result,
        support_values = rules.run_pandora.output.support_values,
        snp_file = rules.simulate_no_missing.output.snp_file,
        ind_file = rules.simulate_no_missing.output.ind_file,
        geno_file = rules.simulate_no_missing.output.geno_file,
        # no missing, LD pruning
        pandora_result_ld = rules.run_pandora_ld_pruned.output.pandora_result,
        support_values_ld = rules.run_pandora_ld_pruned.output.support_values,
        snp_file_ld = rules.plink_to_eigen.output.snp_file,
        ind_file_ld = rules.plink_to_eigen.output.ind_file,
        geno_file_ld = rules.plink_to_eigen.output.geno_file,
        # missing, LD pruning
        pandora_result_missing = expand(rules.run_pandora_ld_pruned_missing.output.pandora_result, missing=MISSING, allow_missing=True),
        support_values_missing = expand(rules.run_pandora_ld_pruned_missing.output.support_values, missing=MISSING, allow_missing=True),
        snp_file_missing = expand(rules.add_random_missing_data.output.snp_file, missing=MISSING, allow_missing=True),
        ind_file_missing = expand(rules.add_random_missing_data.output.ind_file, missing=MISSING, allow_missing=True),
        geno_file_missing = expand(rules.add_random_missing_data.output.geno_file, missing=MISSING, allow_missing=True),
    output:
        result_file = OUTDIR_ALL_POPS / "results.parquet"
    params:
        model = lambda wildcards: wildcards.model,
        seq_len = lambda wildcards: wildcards.seq_len,
    run:
        results = collect_data_for_experiment(
            pathlib.Path(input.pandora_result),
            pathlib.Path(input.support_values),
            pathlib.Path(input.ind_file),
            pathlib.Path(input.snp_file),
            pathlib.Path(input.geno_file),
            0.0,
            False
        )

        results_ld = collect_data_for_experiment(
            pathlib.Path(input.pandora_result_ld),
            pathlib.Path(input.support_values_ld),
            pathlib.Path(input.ind_file_ld),
            pathlib.Path(input.snp_file_ld),
            pathlib.Path(input.geno_file_ld),
            0.0,
            True
        )

        results_missing = [
            collect_data_for_experiment(
                pathlib.Path(input.pandora_result_missing[MISSING.index(missing)]),
                pathlib.Path(input.support_values_missing[MISSING.index(missing)]),
                pathlib.Path(input.ind_file_missing[MISSING.index(missing)]),
                pathlib.Path(input.snp_file_missing[MISSING.index(missing)]),
                pathlib.Path(input.geno_file_missing[MISSING.index(missing)]),
                missing,
                True
            )
            for missing
            in MISSING
        ]

        results = pd.concat([results, results_ld] + results_missing, ignore_index=True)
        results["model"] = params.model
        results["exclude_pops"] = str(MODELS[params.model])
        results["seq_len"] = params.seq_len

        results.to_parquet(pathlib.Path(output.result_file))


rule collect_all_results:
    input:
        expand(rules.collect_results.output.result_file, model=MODELS.keys(), seq_len=SEQ_LENGTHS),
    output:
        result_file = FULL_RESULT / "all_results.parquet",
    run:
        all_results = pd.concat([pd.read_parquet(f) for f in input])
        all_results.to_parquet(output.result_file)